# _*_ coding:utf-8 _*_
# @Time     : 2020/5/30 13:21
# @Auhtor   : laixinping
# @Emial    : xinping_lai@126.com
# @File     : strategy.py
# @software : PyCharm

import datetime
import numpy as np
import pandas as pd
import queue
from abc import ABCMeta, abstractmethod
from event import SignalEvent


class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__  = ABCMeta
    @abstractmethod
    def calculate_signals(self):
        """ Provides the mechanisms to calculate the list of signals.
        :return:
        """
        raise NotImplementedError("Should implement calculate_signals()")


class BuyAndHoldStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """
    def __init__(self, bars, events):
        """ Initialises the buy and hold strategy.
        :param bars: The DataHandler object that provides bar information
        :param events:The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def __calculate_initial_bought(self):
        """ Adds keys to the bought dictionary for all symbols and sets them to False.
        初始化成False
        :return:
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """ for "Buy and Hold" we generate a singal per symbol and
            then no additional signal.This means wa are constantly long
            the market from the date of strategy initialisation.

        :param event:A MarketEvent object.
        :return:  event.type == "MARKET" 说明有新的市场数据加入，只是在最开始的时候 为每个股票 产出买入的信号，之后就不做任何事情
        """
        if event.type == "MARKET":
            for s in self.symbol_list: # 对每一个股票都产生一个买入的信号
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        self.events.put(signal)
                        self.bought[s] = True


if __name__ == "__main__":
    print("strategy.py is ok!!")
